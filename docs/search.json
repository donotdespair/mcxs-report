[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Estimating the impact of monetary policy shocks on different housing indicators: An SVAR Approach",
    "section": "",
    "text": "Abstract. <under construction!>\nKeywords. bsvars, impulse responses, quarto, R, housing price index, monetary policy shocks"
  },
  {
    "objectID": "index.html#empirical-project-setup",
    "href": "index.html#empirical-project-setup",
    "title": "Estimating the impact of monetary policy shocks on different housing indicators: An SVAR Approach",
    "section": "Empirical Project Setup",
    "text": "Empirical Project Setup\nThis project website is being developed as a Quarto document and the empirical work in conducted using R. The necessary datasets are imported from the Reserve Bank of Australia (RBA) and the Australian Bureau of Statistics (ABS) websites using readrba and readabs respectively."
  },
  {
    "objectID": "index.html#choice-of-variables",
    "href": "index.html#choice-of-variables",
    "title": "Estimating the impact of monetary policy shocks on different housing indicators: An SVAR Approach",
    "section": "Choice of variables",
    "text": "Choice of variables\nI use the following variables to answer this question. I discuss the relevance of each variable.\n\n\\(\\log(M1)\\): represents the log of the money supply M1. Both conventional and unconventional monetary policy shocks can change the stock of money supply and its size affects real variables of the economy.\n\\(\\Delta CPI\\): represents the year-on-year change in the Consumer Price Index (CPI). It is a measure of inflation in an economy and is affected by monetary policy shocks.\n\\(\\log(c)\\): represents the log of consumption of the economy. Monetary policy shocks can alter people’s consumption-savings behavior.\n\\(\\log(GDP)\\): represents the log of the Gross Domestic Product (GDP). Including this along with the consumption helps differentiate the effect on the non-consumption aspect of the economy.\n\\(loanrate\\): represents the weighted average interest rates on owner-occupied home loans.\n\\(AUCR\\): represents the Australian Cash Rate Target. This is the major monetary policy instrument available to the RBA.\n\\(USFFR\\): represents the Federal Funds Rate Maximum Target Rate. Monetary policy adopted in the US tend to ripple into other economies so this is a variable of interest. Another extension to this variable would be to include the Target rates of Australia’s largest trading partners.\n\\(nhouses\\): represents the number of new private dwellings (houses) approved for construction in Australia. Impact on housing prices might be dampened by the supply elasticity of housing captured by this variable.\n\\(PPI\\): represents the Property Price Index in Australia. The index is normalized with respect to the property prices in 2011-2012."
  },
  {
    "objectID": "index.html#data-properties",
    "href": "index.html#data-properties",
    "title": "Estimating the impact of monetary policy shocks on different housing indicators: An SVAR Approach",
    "section": "Data Properties",
    "text": "Data Properties\nThe variables discussed above are illustrated in the figure below. Note that the logged variables trend upwards because they are expressed in their levels, while variables expressed in percentage change terms do not exhibit this behavior.\nThe dataset will be used in the sample consists quarterly data from 2003 Q3 to 2021 Q4, including 74 observations, plots of truncated dataset is shown as:\n\n\n\n\nvar_names <- colnames(df)\ndate_range <- as.yearqtr(rownames(df), format = \"%Y Q%q\")\npar(mfrow = c(3,3), mar=c(2,2,2,2))\nfor (j in 1:ncol(df)){\n  plot(x = date_range, y = df[,j],,type='l',\n       main = paste(var_names[j]), ylab = \"\", xlab = \"\",\n       lwd = 2.5,\n       ylim = c(min(df[,j]),max(df[,j])))\n}\n\n\n\n\n\n\n\n\n\n\n\nADF Tests\nNext, I perform and display ADF test results on the variables. I report, for each variable, the difference level at which the ADF tests rejects the null that the series is non-stationary.\n\nperform_adf_tests <- function(df) {\n  # Create an empty dataframe to store the results\n  results <- data.frame(Variable = character(), TestType = character(), \n                        TestStatistic = numeric(), PValue = numeric(), \n                        stringsAsFactors = FALSE)\n\n  # Iterate over each column in the dataframe\n  for (col in colnames(df)) {\n    # Remove NA values from the column\n    column_data <- na.omit(df[[col]])\n\n    # Perform ADF test for levels\n    adf_levels <- tseries::adf.test(na.omit(column_data), k = 4)\n\n    # Check if p-value is less than or equal to 0.05\n    if (adf_levels$p.value <= 0.05) {\n      results <- bind_rows(results,\n        data.frame(Variable = col, TestType = \"Levels\", \n                   TestStatistic = adf_levels$statistic,\n                   PValue = adf_levels$p.value)\n      )\n    } else {\n      # Perform ADF test for first difference\n      adf_diff1 <- tseries::adf.test(na.omit(diff(column_data)), k = 4)\n      \n      # Check if p-value is less than 0.05\n      if (adf_diff1$p.value < 0.05) {\n        results <- bind_rows(results,\n          data.frame(Variable = col, TestType = \"First Difference\", \n                     TestStatistic = adf_diff1$statistic,\n                     PValue = adf_diff1$p.value)\n        )\n      } else {\n        # Perform ADF test for second difference\n        adf_diff2 <- tseries::adf.test(na.omit(diff(column_data, differences = 2)), k = 4)\n        \n        results <- bind_rows(results,\n            data.frame(Variable = col, TestType = \"Second Difference\", \n                       TestStatistic = adf_diff2$statistic,\n                       PValue = adf_diff2$p.value)\n          )\n      }\n    }\n  }\n\n\n  # Return the results dataframe\n  return(results)\n}\n\nadf_test_results <- perform_adf_tests(df)\nrmarkdown::paged_table(adf_test_results)\n\n\n\n  \n\n\n\n\n\nACF Plots\n\n\n\n\n\n\n\nPACF Plots"
  },
  {
    "objectID": "index.html#basic-model",
    "href": "index.html#basic-model",
    "title": "Estimating the impact of monetary policy shocks on different housing indicators: An SVAR Approach",
    "section": "Basic Model",
    "text": "Basic Model\n\nIdentification\nI plan to use exclusion-restrictions to identify the structural matrix \\(B_0\\). In particular, I will employ the solution concept in D. Waggoner and Zha (2003) who use a normalization rule as an optimal solution to the local identification problem. I then employ the Gibbs sampler for a SVAR model with exclusion restrictions as in D. F. Waggoner and Zha (2003).\n\\[ B_0 Y = B_+ X + U, \\qquad \\qquad U|X \\sim \\mathcal{MN}_{N \\times T}(\\textbf{0}_{N \\times T}, I_T, I_N) \\] where\n\\(B_0\\) is a \\(N \\times N\\) contemporaneous effects matrix.\n\\(Y = [y_1, \\dots, y_T]\\) is a \\(N \\times T\\) matrix of observations.\n\\(B_+ = [B_d, B_1, \\dots, B_p]\\) is a \\(N \\times K\\) matrix of autoregressive parameters, where \\(K = Np + d\\) (\\(d\\) is the number of deterministic terms; \\(p\\) is the number of lags).\n\\(X = [x_1, \\dots, x_T]\\) is a \\(K \\times T\\) matrix of lagged observations where each \\(x_t = (1, y_{t-1}, \\dots, y_{t-p})'\\).\n\\(U = [u_1, \\dots, u_T]\\) is a \\(N \\times T\\) matrix of structural shocks.\nFor convenience of coding and inference purposes, we consider a row-wise equation form as follows: \\[ B_{0[n.\\cdot]} Y = B_{+n} X + U_n, \\qquad \\qquad U_n|X \\sim \\mathcal{N}(\\mathbf{0}_T, I_T) \\]\nIf \\(r_n\\) denotes the number of elements in the \\(n^{th}\\) row of \\(B_0\\) that stay unrestricted, then we can further decompose \\(B_{0[n.\\cdot]}\\) into \\(b_n\\) and \\(V_n\\).\n\\(b_n\\) is a \\(1 \\times r_n\\) vector of unrestricted elements in the \\(n^{th}\\) row of \\(B_0\\).\n\\(V_n\\) is a \\(r_n \\times N\\) matrix which places elements of \\(b_n\\) in the appropriate positions to impose the restrictions on \\(B_0\\).\nThen, the row-wise equation form can be written as follows: \\[ b_n V_n Y = B_{+n} X + U_n, \\qquad \\qquad U_n|X \\sim \\mathcal{N}(\\mathbf{0}_T, I_T) \\] Following D. F. Waggoner and Zha (2003) and Arias, Rubio‐Ramírez, and Waggoner (2018), we define that \\((B_+, B_0)\\) follow jointly a Normal-Generalised Normal (NGN) distribution denoted as \\[ p(B_+, B_0) \\sim \\mathcal{NGN}(B, \\Omega, S, \\nu)\\]\nif \\(B_{+n}\\) follows a K-variate normal distribution given \\(b_n\\) \\[ p(B_{+n}|b_n) = \\mathcal{N}_k(b_nV_nB, \\Omega) \\] with kernel \\[ p(B_{+n}|b_n) \\propto \\exp \\left\\{  -\\frac{1}{2} \\left( B_{+n} - b_nV_nB \\right) \\Omega^{-1}  \\left( B_{+n} - b_nV_nB \\right)' \\right\\} \\]\nfor \\(n = 1, \\dots, N\\) and \\(b_1, \\dots, b_N\\) jointly have a distribution whose kernel is specified by \\[ p(b_1, \\dots, b_N) \\propto | \\det(B_0) |^{\\nu - N} \\exp \\left\\{  -\\frac{1}{2} \\sum_{n=1}^N b_n V_n S^{-1} V_n' b_n'  \\right\\} \\]\nThe joint-distribution of \\((B_+, B_0)\\) can then be written as \\[ p(B_0, B_+) = \\left( \\prod_{n=1}^N p(B_{+n}|b_n)\\right) p(b_1, \\dots, b_N) \\]\n\nltexclusion = function(usedata){\n  BM.V        = vector(\"list\",usedata$N)\nfor (n in 1:usedata$N){\n  BM.V[[n]]   = cbind(diag(n),matrix(0,n,usedata$N-n))\n}\n\nB0.initial    = matrix(0,usedata$N,usedata$N)\nfor (n in 1:usedata$N){\n  unrestricted               = apply(BM.V[[n]],2,sum)==1\n  B0.initial[n,unrestricted] = rnorm(sum(unrestricted))\n}\nB0Vlist       = list(B0.initial = B0.initial, V = BM.V)\n}\n\n\n\nPrior distribution\nGiven this parameterisation, we can write down the kernel of the prior given hyperparameters \\((\\underline B, \\underline \\Omega, \\underline S, \\underline \\nu)\\) as follows: \\[ | \\det(B_0) |^{\\underline \\nu - N} \\exp \\left\\{  -\\frac{1}{2} \\sum_{n=1}^N b_n V_n \\underline S^{-1} V_n' b_n'  \\right\\}  \\exp \\left\\{  -\\frac{1}{2}  \\sum_{n=1}^N  \\left( B_{+n} - b_nV_n \\underline B \\right) \\underline \\Omega^{-1}  \\left( B_{+n} - b_nV_n \\underline B \\right)' \\right\\}  \\] This prior distribution has two key advantages. Firstly, it leads to a full-conditional posterior distributions that allow efficient sampling. This allows us to estimate the structural parameters of the SVAR model.\nSecondly, it belongs to a class of reference prior distributions that are invariant to the pre-multiplication of the parameter matrices by a rotation matrix up to which the system is identified (see Rubio-Ramirez, Waggoner, and Zha (2010)). This allows us to conduct a proper Bayesian treatment of this model given the identification above.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCalibration of the prior\n\n\\(\\underline \\nu = N\\) is a commonly chosen value as it implies that the generalised-normal part is equivalent to a \\(r_n\\)-variate normal with the mean equal to a vector of zeros and the covariance matrix equal to \\(\\underline S\\).\n\\(\\underline S = \\kappa_3 I_N\\) implies that the covariances across the rows of \\(B_0\\) is zero, and the variance of each row is homoskedastic (constant). \\(\\kappa_3\\) can be interpreted as a contemporaneous effects shrinkage and is set to 10.\n\\(\\underline B = [0_{N \\times 1} \\; \\kappa_4 I_N \\; 0_{N \\times (p-1)N}]\\) implies an AR1 process for the structural VAR at the prior mean. In this calibration, \\(\\kappa_4 = 1\\), the AR1 process is a random walk process.\n\\(\\underline \\Omega = \\begin{pmatrix} \\kappa_2 & 0\\\\ 0 & \\kappa_1 I_{Np} \\end{pmatrix}\\) is the prior covariance matrix. It is taken to be a diagonal matrix with the diagonal elements set as the Litterman prior. \\(\\kappa_2\\) represents the constant term shrinkage and is set to 10. \\(\\kappa_1\\) represents the autoregressive slope shrinkage and is set to 0.1.\n\n\n# A function that computes and stores all the prior distribution components given a parameter list input\nprior     = function(parameters, usedata){\n  priors  = list(\n  B       = cbind(rep(0,usedata$N), parameters$kappa4*diag(usedata$N), matrix(0, usedata$N, (usedata$p-1)*usedata$N)), # random walk prior\n  Omega   = diag(c(parameters$kappa2,parameters$kappa1*((1:usedata$p)^(-2))%x%rep(1,usedata$N))),\n  # Omega = diag(c(parameters$kappa2,parameters$kappa1*rep(1,usedata$N*usedata$p))),\n  S       = parameters$kappa3*diag(usedata$N),\n  nu      = usedata$N\n  )\n}\n\n\n# set the priors\n\nparameters = list(\n  kappa1    = .1,       # autoregressive slope shrinkage\n  kappa2    = 10,      # constant term shrinkage\n  kappa3    = 10,      # contemporaneous effects shrinkage\n  kappa4    = 1,       # VAR prior persistence\n  S         = 5000,\n  S.burnin  = 100\n)\n\nWe also calibrate the number of draws \\(S = 5000\\) for any sampling, while the \\(S.burnin = 100\\) represents the number of draws that are sampled first and then discarded.\n\n\n\nLikelihood Function\nThe conditional normality of the error term allows us to write the kernel of the likelihood function and show that it can be expressed as a NGN distribution. \\[\n\\begin{align*}\n    &L(B_+, B_0|Y,X) \\propto | \\det(B_0^{-1}B_0^{-1'})|^{-\\frac{T}{2}} \\exp \\left\\{  -\\frac{1}{2} \\sum_{n=1}^N \\left(b_n V_n Y - B_{+n} X \\right) \\left( b_n V_n Y - B_{+n} X  \\right)' \\right\\}\\\\\n    & = | \\det(B_0)|^{T} \\exp \\left\\{  -\\frac{1}{2} \\sum_{n=1}^N \\left( b_n V_n Y Y' V_n' b_n' - 2 b_n V_n Y X' B_{+n}' + B_{+n} X X' B_{+n}' \\right) \\right\\}\\\\\n    & = | \\det(B_0)|^{T} \\exp \\left\\{  -\\frac{1}{2} \\sum_{n=1}^N \\left( b_n V_n Y Y' V_n' b_n' + B_{+n} X X' B_{+n}' - 2 b_n V_n Y X' (XX')^{-1} (XX') B_{+n}' \\right. \\right. \\\\\n    & \\left. \\left. + b_n V_n Y X' (XX')^{-1} (XX') (XX')^{-1} XY'V_n'b_n' - b_n V_n Y X' (XX')^{-1} (XX') (XX')^{-1} XY'V_n'b_n' \\right) \\right\\}\\\\\n    & = | \\det(B_0)|^{T} \\exp \\left\\{  -\\frac{1}{2} \\sum_{n=1}^N \\left( b_n V_n [ YY' - YX'(XX')^{-1}XY'] V_n' b_n'  + B_{+n} X X' B_{+n}' \\right. \\right. \\\\\n    & \\left. \\left. - 2 b_n V_n Y X' (XX')^{-1} (XX') B_{+n}' + b_n V_n Y X' (XX')^{-1} XY' V_n' b_n' \\right) \\right\\}\\\\\n    & \\text{}\\\\\n    & \\text{Let $\\hat A = YX' (XX')^{-1} $, then we can simplify}\\\\\n    & \\text{}\\\\\n    & =  | \\det(B_0)|^{T} \\exp \\left\\{  -\\frac{1}{2} \\sum_{n=1}^N \\left( b_n V_n [ YY' - \\hat A XY'] V_n' b_n'  + B_{+n} X X' B_{+n}' - 2 b_n V_n \\hat A (XX') B_{+n}' \\right. \\right.\\\\ & \\left. \\left. + b_n V_n \\hat A XY' V_n' b_n' \\right) \\right\\}\\\\\n    & =  | \\det(B_0)|^{T} \\exp \\left\\{  -\\frac{1}{2} \\sum_{n=1}^N \\left( b_n V_n [ YY' - \\hat A XY'] V_n' b_n'  + (B_{+n} - b_n V_n \\hat A) X X' (B_{+n} - b_n V_n \\hat A)' \\right) \\right\\}\\\\\n    & =  | \\det(B_0)|^{T} \\exp \\left\\{  -\\frac{1}{2} \\sum_{n=1}^N b_n V_n [ YY' - \\hat A XY'] V_n' b_n' \\right\\} \\exp \\left\\{  -\\frac{1}{2} \\sum_{n=1}^N (B_{+n} - b_n V_n \\hat A) X X' (B_{+n} - b_n V_n \\hat A)' \\right\\}\n\\end{align*}\n\\]\nComparing this with the general NGN kernel, we can write that\n\\[ L(B_+, B_0|Y, X) = \\mathcal{NGN}(\\tilde B, \\tilde \\Omega, \\tilde S, \\tilde \\nu) \\] where\n\\[ \\tilde B = \\hat A, \\quad \\tilde \\Omega = (XX')^{-1}, \\quad \\tilde S = ( YY' - \\hat A XY')^{-1}, \\quad \\tilde \\nu = T + N. \\] Hence, we have shown that the likelihood function follows a NGN distribution.\n\n\nPosterior Distribution\nThe prior and the likelihood can be used to obtain the posterior as follows:\n\\[\n\\begin{align*}\n    & p(B_+, B_0|Y, X)  \\propto L(B_+, B_0|Y, X) p(B_0, B_+)\\\\\n    & = | \\det(B_0)|^{T} \\exp \\left\\{  -\\frac{1}{2} \\sum_{n=1}^N \\left(b_n V_n Y - B_{+n} X \\right) \\left( b_n V_n Y - B_{+n} X  \\right)' \\right\\}\\\\\n    & \\times | \\det(B_0) |^{\\underline \\nu - N} \\exp \\left\\{  -\\frac{1}{2} \\sum_{n=1}^N b_n V_n \\underline S^{-1} V_n' b_n'  \\right\\}  \\exp \\left\\{  -\\frac{1}{2}  \\sum_{n=1}^N  \\left( B_{+n} - b_nV_n \\underline B \\right) \\underline \\Omega^{-1}  \\left( B_{+n} - b_nV_n \\underline B \\right)' \\right\\} \\\\\n    & =  | \\det(B_0) |^{T + \\underline \\nu - N} \\exp \\left\\{  -\\frac{1}{2} \\sum_{n=1}^N \\left(b_n V_n Y Y' V_n' b_n' - 2 b_n V_n Y X' B_{+n}' + B_{+n} X X' B_{+n}' \\right) \\right.\\\\\n    & \\left. + b_n V_n \\underline S^{-1} V_n' b_n' + B_{+n} \\underline \\Omega^{-1} B_{+n}' - 2 b_n V_n \\underline B \\underline \\Omega^{-1} B_{+n}' + b_n V_n \\underline B \\underline \\Omega^{-1} \\underline B' V_n' b_n' \\right\\}\\\\\n    & =  | \\det(B_0) |^{T + \\underline \\nu - N} \\exp \\left\\{  -\\frac{1}{2} \\sum_{n=1}^N b_n V_n [ YY' + \\underline S^{-1} + \\underline B \\underline \\Omega^{-1} \\underline B'] V_n' b_n' - 2 b_n V_n [ YX' + \\underline B \\underline \\Omega^{-1} ] B_{+n}' \\right.\\\\\n    & \\left. + B_{+n} [ XX' + \\underline \\Omega^{-1} ] B_{+n}' \\right\\}\\\\ & \\text{}\\\\\n    & \\text{ Let $ \\bar \\Omega = (XX' + \\underline \\Omega^{-1})^{-1} $, then we can write}\\\\ & \\text{}\\\\\n    & =  | \\det(B_0) |^{T + \\underline \\nu - N} \\exp \\left\\{  -\\frac{1}{2} \\sum_{n=1}^N b_n V_n [ YY' + \\underline S^{-1} + \\underline B \\underline \\Omega^{-1} \\underline B'] V_n' b_n' - 2 b_n V_n [ YX' + \\underline B \\underline \\Omega^{-1} ] \\bar \\Omega \\bar \\Omega^{-1} B_{+n}' \\right.\\\\\n    & \\left. + B_{+n} \\bar \\Omega^{-1} B_{+n}' \\right\\}\\\\\n    & \\text{}\\\\\n    & \\text{ Let $ \\bar B = (YX' + \\underline B \\underline \\Omega^{-1}) \\bar \\Omega $, then we can write}\\\\ & \\text{}\\\\\n    & =  | \\det(B_0) |^{T + \\underline \\nu - N} \\exp \\left\\{  -\\frac{1}{2} \\sum_{n=1}^N b_n V_n [ YY' + \\underline S^{-1} + \\underline B \\underline \\Omega^{-1} \\underline B' - \\bar B \\bar \\Omega^{-1} \\bar B' ] V_n' b_n'  \\right.\\\\\n    & \\left.  + b_n V_n  \\bar B \\bar \\Omega^{-1} \\bar B' V_n' b_n' - 2 b_n V_n \\bar B \\bar \\Omega^{-1} B_{+n}' + B_{+n} \\bar \\Omega^{-1} B_{+n}' \\right\\}\\\\\n    & \\text{}\\\\\n    & \\text{ Define $ \\bar S = (YY' + \\underline S^{-1} + \\underline B \\underline \\Omega^{-1} \\underline B' - \\bar B \\bar \\Omega^{-1} \\bar B')^{-1} $, then we can write}\\\\ & \\text{}\\\\\n    & =  | \\det(B_0) |^{T + \\underline \\nu - N} \\exp \\left\\{  -\\frac{1}{2} \\sum_{n=1}^N b_n V_n \\bar S^{-1} V_n' b_n'  + (B_{+n} - b_n V_n \\bar B) \\bar \\Omega^{-1} (B_{+n} - b_n V_n \\bar B)' \\right\\}\\\\\n    &  = | \\det(B_0) |^{T + \\underline \\nu - N} \\exp \\left\\{  -\\frac{1}{2} \\sum_{n=1}^N b_n V_n \\bar S^{-1} V_n' b_n'  \\right\\} \\exp \\left\\{  -\\frac{1}{2} \\sum_{n=1}^N (B_{+n} - b_n V_n \\bar B) \\bar \\Omega^{-1} (B_{+n} - b_n V_n \\bar B)' \\right\\}\n\\end{align*}\n\\] Thus, \\[ p(B_+, B_0|Y,X) \\sim \\mathcal{NGN}(\\bar B, \\bar \\Omega, \\bar S, \\bar \\nu) \\] where the first three parameters are defined above and \\(\\bar \\nu = T + \\underline \\nu\\).\nThe following R function uses the prior and information contained in data to compute and store (as a list) the set of posterior parameters for our model.\n\nposterior     = function(priors, usedata){\n  Omega.inv   = solve(priors$Omega)\n  Omega.post.inv = usedata$X%*%t(usedata$X) + Omega.inv\n  Omega.post  = solve( Omega.post.inv )\n  B.post      = (usedata$Y%*%t(usedata$X) + priors$B%*%Omega.inv) %*% Omega.post\n  S.post      = solve(usedata$Y%*%t(usedata$Y) + solve(priors$S) + priors$B%*%Omega.inv%*%t(priors$B) - B.post%*%Omega.post.inv%*%t(B.post) )\n  nu.post     = ncol(usedata$Y) + priors$nu\n\n  posteriors  = list(\n  B           = B.post,\n  Omega       = Omega.post,\n  S           = S.post,\n  nu          = nu.post\n)\n}\n\nThe following is the code to sample using the Gibbs sampler. More information on the specifics of this code will be added soon.\n\nposteriorSimulations  = function(parameters, posteriors, B0Vlist, N){\n  t0                  = proc.time()\n  B0.posterior        = rgn(n=parameters$S.burnin, S.inv=solve(posteriors$S), nu=posteriors$nu, V=B0Vlist$V, B0.initial=B0Vlist$B0.initial)\n  t1                  = proc.time()\n  (t1-t0)/60\n  \n  # sampling B0 from the posterior distribution using Gibbs\n  t0                  = proc.time()\n  B0.posterior        = rgn(n=parameters$S, S.inv=solve(posteriors$S), nu=posteriors$nu, V=B0Vlist$V, B0.initial=B0.posterior[,,parameters$S.burnin])\n  t1                  = proc.time()\n  (t1-t0)/60\n  \n  # normalisation\n  B0.hat              = t(chol((posteriors$nu-N)*posteriors$S))                   # normalisation using this B0.hat should work\n  BM.B0.posterior     = normalize.Gibbs.output.parallel(B0.posterior,B0.hat=B0.hat)\n  t2                  = proc.time()\n  (t2-t1)/60\n  \n  # sample B+ from the normal conditional posterior\n  t2                  = proc.time()\n  BM.Bp.posterior     = rnorm.ngn(BM.B0.posterior, B=posteriors$B,Omega=posteriors$Omega)\n  t3                  = proc.time()\n  (t3-t2)/60\n  \n  list(B0.posterior   = BM.B0.posterior, Bp.posterior = BM.Bp.posterior)\n}\n\nThis function computes the sample average of the \\(B_0\\) and \\(B_+\\) matrices obtained from each sampling step.\n\nposteriorMeans = function(Bposteriors){\n  Bposteriors.means = list(\n  B0 = rowMeans(Bposteriors$B0.posterior, dims = 2),\n  Bp = rowMeans(Bposteriors$Bp.posterior, dims = 2)\n  )\n}\n\n\n\nSimulation Run\nThe following code generates artificial data containing 1000 observations from a bi-variate Gaussian random walk process with the covariance matrix equal to the identity matrix of order 2.\n\nset.seed(12345)\n\nsim.p = 1\nsim.T = 1000\nsim.N = 2\nsim.K = 1 + sim.N*sim.p\n\nsim.Y           = arima.sim(list(order = c(0,1,0)), n = sim.T + sim.p-1, mean = 0, sd =1)\nfor (i in 2:sim.N){\n  sim.Y         = rbind(sim.Y, arima.sim(list(order = c(0,1,0)), n = sim.T + sim.p-1, mean = 0, sd = 1))\n}\n\nsim.X           = matrix(1,1,sim.T)\nfor (i in 1:sim.p){\n  sim.X         = rbind(sim.X, sim.Y[,(sim.p+1-i):(ncol(sim.Y)-i)])\n}\nsim.Y           = sim.Y[,-sim.p]\nartificialdata  = list(p = sim.p, N = sim.N, K = sim.K, Y = sim.Y, X = sim.X)\n\nWe obtain a list of simulation priors and posteriors.\n\nsim.priors      = prior(parameters, artificialdata)\nsim.posteriors  = posterior(sim.priors, artificialdata)\n\nWe create a list of \\(V_n\\) and \\(b_n\\) corresponding to a lower triangular exclusion restriction on \\(B_0\\).\n\nsim.B0Vlist   = ltexclusion(artificialdata)\n\nWe sample the \\(B_0\\) and \\(B_p\\) posteriors using the Gibbs sampler, and save the data for future use.\n\n\n\n\n\n\nsim.Bposteriors.means = posteriorMeans(sim.Bposteriors)\nsim_B0 = pmatrix(sim.Bposteriors.means$B0)\n\\[\\begin{equation*}\n\\left(\n\\begin{array}{cc}\n1.007094 & 0.000000\\\\\n-0.037662 & 1.000047\\\\\n\\end{array}\n\\right)\\, .\n\\end{equation*}\\]\nWe can see that the computed \\(B_0\\) covariance matrix is numerically identical to an identity matrix.\nsim_Bp = pmatrix(sim.Bposteriors.means$Bp)\n\\[\\begin{equation*}\n\\left(\n\\begin{array}{ccc}\n0.2276255 & 0.9989406 & -0.0071993\\\\\n-0.1389968 & -0.0461782 & 0.9791025\\\\\n\\end{array}\n\\right)\\, .\n\\end{equation*}\\]\nThe first column of \\(B_+\\) represents the posterior mean of the constant term. The values are small and close to zero. The rest of the \\(B_+\\) matrix represents the autoregressive matrix. Its posterior mean is numerically equal to an identity matrix.\n\n\nData Results\n\n# Y is N by T; X is K by T\n\np = 4                                   # set a number of lags included\nN = ncol(df)\nK = 1 + N*p\n\nY = t(df[(p+1):nrow(df),])\nX = matrix(1,1,ncol(Y))\n\nfor (i in 1:p){\n  X    = rbind(X,t(df[((p+1):nrow(df))-i,]))\n}\n\nmydata = list(p=p,N=N,K=K,Y=Y,X=X)\n\n\npriors     = prior(parameters, mydata)\nposteriors = posterior(priors, mydata)\n\n\nB0Vlist       = ltexclusion(mydata)\n\n\n\n\n\n\n\nBposterior.means = posteriorMeans(Bposteriors)\ndata_B0 = pmatrix(Bposterior.means$B0)\n\\[\\begin{equation*}\n\\left(\n\\begin{array}{ccccccccc}\n23.1134969 & 0.0000000 & 0.0000000 & 0.0000000 & 0.000000 & 0.0000000 & 0.0000000 & 0.000000 & 0.0000000\\\\\n1.2243455 & 3.5998319 & 0.0000000 & 0.0000000 & 0.000000 & 0.0000000 & 0.0000000 & 0.000000 & 0.0000000\\\\\n-0.1342092 & -1.7658174 & 3.1536584 & 0.0000000 & 0.000000 & 0.0000000 & 0.0000000 & 0.000000 & 0.0000000\\\\\n-0.4712197 & -0.4609153 & -0.5655685 & 1.7292316 & 0.000000 & 0.0000000 & 0.0000000 & 0.000000 & 0.0000000\\\\\n-0.6426257 & -0.0886438 & 0.0044528 & -0.0679792 & 24.864814 & 0.0000000 & 0.0000000 & 0.000000 & 0.0000000\\\\\n-0.1622557 & -0.1092761 & -0.0039268 & -0.0770793 & -3.147955 & 26.7743704 & 0.0000000 & 0.000000 & 0.0000000\\\\\n0.2104459 & -0.8435216 & 0.3559852 & -0.3599073 & -1.289018 & 0.4306629 & 3.4453897 & 0.000000 & 0.0000000\\\\\n-0.0185730 & -0.2117857 & 0.3279233 & -0.2649446 & -2.257497 & -0.8451789 & -0.2465900 & 19.858922 & 0.0000000\\\\\n-3.6618848 & 0.3646893 & 0.0264780 & -0.4940499 & -4.898343 & -2.9525804 & 0.1068924 & -0.691785 & 0.6376781\\\\\n\\end{array}\n\\right)\\, .\n\\end{equation*}\\]\ndata_Bp = pmatrix(Bposterior.means$Bp)\n\\[\\begin{equation*}\n\\left(\n\\begin{array}{ccccccccccccccccccccccccccccccccccccc}\n0.4592425 & 23.2090864 & 0.0246270 & 0.0168338 & 0.0104643 & 0.0275067 & 0.0841825 & -0.2775286 & -0.0440055 & -0.0139648 & 0.0257517 & -0.0208809 & 0.0008640 & 0.0338776 & 0.0116874 & 0.0173025 & 0.0549422 & -0.0034379 & 0.0360598 & 0.0081823 & 0.0053343 & 0.0378987 & 0.0082165 & 0.0064112 & 0.0073730 & 0.0146762 & -0.0006674 & -0.0423029 & 0.0087433 & -0.0170215 & 0.0370567 & 0.0077154 & 0.0027574 & 0.0039111 & 0.0132191 & -0.0003049 & 0.0155405\\\\\n1.1728236 & 1.1590424 & 3.0257692 & 0.2110848 & -0.0388587 & 0.0348908 & -0.0225750 & 1.1432012 & 0.1306784 & 0.0238832 & -0.0103440 & -0.1693940 & 0.0382343 & -0.1763616 & 0.0084574 & -0.0051621 & -0.1978224 & 0.0193427 & 0.0327776 & -0.0022619 & -0.0867656 & 0.0077647 & -0.0624473 & 0.0034557 & -0.0021986 & -0.0929815 & 0.0082265 & -0.0359360 & -0.0040714 & -0.0250982 & -0.0671338 & -0.0303696 & 0.0001985 & 0.0001676 & -0.0536388 & 0.0055033 & -0.0506214\\\\\n3.5393989 & -0.1238619 & -1.7671493 & 3.2561049 & -0.0500580 & 0.0915237 & 0.0206302 & -0.3740132 & 0.1673298 & -0.1374286 & 0.0015295 & 0.0236392 & -0.0909828 & 0.0943866 & 0.0227600 & 0.0042347 & -0.0416196 & 0.0559773 & 0.0997202 & 0.0071779 & 0.0060580 & -0.1181274 & 0.0776006 & 0.0119727 & -0.0027412 & -0.0098416 & 0.0289854 & 0.0316997 & 0.0040410 & -0.0204077 & -0.1029836 & -0.0125719 & 0.0054109 & -0.0025148 & -0.0065416 & 0.0145336 & -0.0127000\\\\\n-0.7928774 & -0.3945453 & -0.3192146 & -0.6229388 & 1.2830954 & -0.0820482 & -0.0439679 & 0.1445452 & 0.0272865 & 0.1228458 & 0.0125715 & -0.0123259 & 0.0584639 & -0.1322286 & -0.0172868 & -0.0121868 & 0.0428789 & 0.0049328 & -0.0970757 & 0.0095090 & 0.0109863 & -0.0045584 & -0.0505445 & -0.0136047 & -0.0074866 & -0.0077460 & 0.0005449 & -0.0376243 & 0.0029729 & 0.0093004 & 0.0235740 & -0.0508965 & -0.0024165 & -0.0017716 & 0.0056085 & 0.0014551 & 0.0198391\\\\\n0.3158823 & -0.6131200 & -0.0821902 & 0.0914809 & 0.1215542 & 24.8408571 & -0.0185280 & -0.0284652 & 0.0326410 & -0.0326914 & 0.0108754 & -0.0154142 & -0.0695890 & -0.1460096 & -0.0030532 & 0.0004267 & -0.0118647 & 0.0051792 & 0.0115814 & 0.0001458 & 0.0058127 & -0.0186554 & 0.0378128 & 0.0013323 & -0.0020123 & -0.0021645 & 0.0004980 & 0.0430695 & 0.0020000 & 0.0026696 & -0.0093246 & 0.0148917 & 0.0020300 & 0.0007384 & 0.0028796 & 0.0030674 & -0.0237915\\\\\n-0.1376712 & -0.1410158 & -0.0558507 & 0.0401332 & 0.1092518 & -3.1683786 & 26.7377810 & 0.0280627 & 0.0401058 & -0.0050778 & 0.0063631 & -0.0081335 & -0.0303484 & -0.0682042 & -0.0033374 & -0.0086254 & 0.0067044 & 0.0098990 & -0.0210244 & -0.0001024 & -0.0164291 & -0.0061704 & -0.0142387 & -0.0036299 & -0.0016865 & -0.0053583 & 0.0026401 & 0.0289747 & -0.0007787 & -0.0113695 & -0.0010339 & -0.0109017 & -0.0008108 & -0.0007651 & -0.0117076 & -0.0006149 & -0.0003343\\\\\n2.9411426 & 0.2309491 & -0.8938928 & 0.5334657 & -0.5589124 & -1.1475611 & 0.5434951 & 3.1967833 & 0.0803523 & 0.0506425 & 0.0113768 & -0.0564354 & 0.0836320 & -0.0746880 & 0.0316792 & 0.0270564 & -0.0443725 & 0.0167949 & -0.0252661 & 0.0017669 & 0.0123187 & -0.0957440 & -0.0219972 & 0.0166386 & 0.0128811 & -0.0344807 & 0.0093411 & -0.0490829 & 0.0037620 & 0.0215630 & -0.0544799 & 0.0380346 & 0.0055936 & 0.0049122 & 0.0127795 & 0.0069271 & -0.0030798\\\\\n2.2748198 & 0.2128722 & -0.5405608 & 0.2468781 & -0.5354887 & -2.1498862 & -0.6989311 & -0.3854837 & 19.8219208 & -0.0673684 & 0.0537483 & -0.0088229 & 0.0031912 & -0.1126389 & 0.0271293 & 0.0437417 & -0.0315590 & -0.0371653 & 0.0282930 & 0.0183686 & 0.0406593 & 0.0516888 & 0.0224315 & 0.0146905 & 0.0211715 & 0.0163835 & -0.0179309 & 0.0082650 & 0.0087426 & 0.0513071 & 0.0490258 & 0.0271478 & 0.0110415 & 0.0124797 & 0.0355640 & -0.0062934 & -0.0038078\\\\\n1.3417767 & -3.3901367 & 0.0736536 & 0.0640109 & -0.1902500 & -4.8347526 & -2.8321506 & -0.0812237 & -0.5256038 & 0.9681112 & 0.0687183 & -0.0318714 & -0.0206400 & -0.1381807 & 0.0066922 & 0.0270728 & -0.0489003 & 0.0306144 & -0.2887816 & 0.0252596 & 0.0126809 & 0.0165759 & -0.0248150 & 0.0050818 & 0.0073304 & 0.0108545 & 0.0052411 & -0.1345780 & 0.0162730 & -0.0022095 & 0.0158700 & 0.0286520 & 0.0030796 & 0.0047718 & 0.0164960 & 0.0016949 & 0.0624001\\\\\n\\end{array}\n\\right)\\, .\n\\end{equation*}\\]"
  },
  {
    "objectID": "index.html#extended-model",
    "href": "index.html#extended-model",
    "title": "Estimating the impact of monetary policy shocks on different housing indicators: An SVAR Approach",
    "section": "Extended Model",
    "text": "Extended Model\nIn the extended model, I will estimate the hyperparameters rather than setting them exogenously. Such estimation procedure often improves the fit of the model especially because the results can be sensitive to the parameterisation of the hyperparameters. In particular, I estimate \\((\\kappa_0, \\kappa_+)\\) such that \\(\\underline S = \\kappa_0 I_N\\) and \\(\\underline \\Omega = \\kappa_+ I_K\\).\nI postulate the following prior distributions for the hyperparameters: \\[\n\\begin{align*}\n    \\kappa_0 | \\underline s_{\\kappa_0}, \\underline \\nu_{\\kappa_0} \\sim \\mathcal{IG}2(\\underline s_{\\kappa_0}, \\underline \\nu_{\\kappa_0})  && \\kappa_+ | \\underline s_{\\kappa_+}, \\underline \\nu_{\\kappa_+} \\sim \\mathcal{G}(2 \\underline s_{\\kappa_+}, \\frac{1}{2} \\underline \\nu_{\\kappa_+})\n  \\end{align*}\n\\]\n\next.priors = function(parameters,usedata){\n  ext.prior = list(\n  kappa0.s = .1,\n  kappa0.nu = 1,\n  kappap.s = .1,\n  kappap.nu = 1,\n  B       = cbind(rep(0,usedata$N), diag(usedata$N), matrix(0, usedata$N, (usedata$p-1)*usedata$N)), # random walk prior\n  Omega   = parameters$kappa1 * diag(usedata$K),\n  S       = parameters$kappa3*diag(usedata$N),\n  nu      = usedata$N\n)\n}\n\nMoreover, we have \\[\n  \\begin{align*}\n    p(B_{+n}|b_n, \\kappa_+) = \\mathcal{N}_k (b_n V_n B, \\kappa_+ \\Omega) && p(b_n| \\kappa_0) = \\mathcal{N}_{r_n}(0, \\kappa_0 S)\n  \\end{align*}\n\\] Thus, posteriors \\[\n\\begin{align*}\n    & p(\\kappa_0 | Y, X, B_0) \\propto p(B_0|\\kappa_0) p(\\kappa_0 | \\underline s_{\\kappa_0}, \\underline \\nu_{\\kappa_0} )\\\\\n    & \\propto \\kappa_0^{-\\frac{N}{2}} \\exp \\left\\{  -\\frac{1}{2} \\sum_{n=1}^N b_n V_n (\\kappa_0 I_N)^{-1} V_n' b_n'  \\right\\} \\cdot \\kappa_0^{-\\frac{\\underline \\nu_{\\kappa_0}+2}{2}} \\exp \\left\\{  -\\frac{\\underline s_{\\kappa_0}}{2 \\kappa_0} \\right\\}\\\\\n    & \\propto \\kappa_0^{ -\\frac{\\underline \\nu_{\\kappa_0} + 2 + N}{2}} \\cdot \\exp \\left\\{  -\\frac{1}{2 \\kappa_0} \\sum_{n=1}^N b_n V_n V_n' b_n' + \\underline s_{\\kappa_0} \\right\\}\\\\\n  \\end{align*}\n  \\] This gives \\[ \\bar s_{\\kappa_0} =  \\sum_{n=1}^N b_n V_n V_n' b_n' + \\underline s_{\\kappa_0}. \\] \\[ \\bar \\nu_{\\kappa_0} = \\underline \\nu_{\\kappa_0} +N \\] Also, \\[\n  \\begin{align*}\n    & p(\\kappa_+ | Y, X, B_+, B_0, \\kappa_0) \\propto p(B_+|\\kappa_+, B_0, \\kappa_0) p(\\kappa_+ | \\underline s_{\\kappa_+}, \\underline \\nu_{\\kappa_+} )\\\\\n    & \\propto \\kappa_+^{-\\frac{N}{2}} \\exp \\left\\{  -\\frac{1}{2} \\sum_{n=1}^N (B_{+n} - b_n V_n \\underline B) (\\kappa_+ I_{K})^{-1} (B_{+n} - b_n V_n \\underline B)'  \\right\\} \\cdot \\kappa_+^{-\\frac{\\underline \\nu_{\\kappa_+} + 2}{2}} \\exp \\left\\{  -\\frac{ \\kappa_+}{2 \\underline s_{\\kappa_+}} \\right\\}\\\\\n    & = \\kappa_+^{-\\frac{\\underline \\nu_{\\kappa_+} + N}{2} - 1} \\cdot \\exp \\left\\{  -\\frac{1}{2} \\left( (B_{+n} - b_n V_n \\underline B)  (B_{+n} - b_n V_n \\underline B)' \\cdot \\frac{1}{\\kappa_+} + \\frac{1}{\\underline s_{\\kappa_+}} \\kappa_+  \\right) \\right\\}\\\\\n  \\end{align*}\n  \\] This gives \\[ \\lambda = -\\frac{\\underline \\nu_{\\kappa_+} + N}{2} \\] \\[ \\chi =  \\sum_{n=1}^N  (B_{+n} - b_n V_n \\underline B)  (B_{+n} - b_n V_n \\underline B)' \\] \\[  \\Psi = \\frac{1}{\\underline s_{\\kappa_+}} \\]\nA structure function is written that creates matrices to store draws of \\(\\{\\kappa_0^{(s)}, \\kappa_+^{(s)}, B_0^{(s)}, B_+^{(s)}\\}_{s =1}^{S}\\).\n\n  init.struct = function(usedata,S){\n    kappa0 = array(NA,c(1,S))\n    kappa0[1] = 10\n    kappap = rep(NA, S)\n    kappap[1] = 1\n    B0.post = array(NA, c(usedata$N,usedata$N,S))\n    Bp.post = array(NA, c(usedata$N,usedata$K,S))\n    list(kappa0 = kappa0, kappap = kappap, B0.post = B0.post, Bp.post = Bp.post)\n  }\n\nThe sampling function is given below.\n\next.sampling = function(parameters, struct, priors, usedata){\n  B0Vlist.initial = ltexclusion(usedata)\n  B0.initial = B0Vlist.initial$B0\n  for (i in 1:(parameters$S + parameters$S.burnin)){\n    \n    # Computing posterior parameters for each draw\n    Omega.inv      = solve(struct$kappap[i] * priors$Omega)\n    Omega.post.inv = usedata$X%*%t(usedata$X) + Omega.inv\n    Omega.post     = solve(Omega.post.inv)\n    B.post         = (usedata$Y%*%t(usedata$X) + priors$B%*%Omega.inv) %*% Omega.post\n    S.post         = solve(usedata$Y%*%t(usedata$Y) + solve(struct$kappa0[i] * priors$S) + priors$B%*%Omega.inv%*%t(priors$B) - B.post%*%Omega.post.inv%*%t(B.post) )\n    nu.post        = ncol(usedata$Y) + priors$nu\n\n\n  if (i > 1){\n    B0.initial = struct$B0.post[,,i-1]\n  }\n  \n  B0.i = rgn(n=1, S.inv = solve(S.post), nu = nu.post, V = B0Vlist.initial$V, B0.initial = B0.initial)\n  B0.hat = t(chol((nu.post - usedata$N)*S.post))\n  B0.norm.i = normalize.Gibbs.output.parallel(B0.i, B0.hat)\n  Bp.i = rnorm.ngn(B0.norm.i, B.post, Omega.post)\n  \n  struct$B0.post[,,i] = B0.norm.i\n  struct$Bp.post[,,i] = Bp.i\n  \n  # Now, update kappa\n  kappa0.nu.post = priors$kappa0.nu + usedata$N\n  kappap.lambda.post = -(priors$kappap.nu + usedata$N)/2\n  kappap.psi.post = 1/priors$kappap.s\n  kappa0.s.post = priors$kappa0.s\n  # kappap.chi.post = 0\n  for (n in 1:usedata$N){\n    # kappa0.s.post = kappa0.s.post + B0.norm.i[n,,1] %*% t( B0.norm.i[n,,1])\n    kappa0.s.post = kappa0.s.post + sum(B0.norm.i[n,,1]^2)\n    kappap.chi.post = (Bp.i[n,,1] - B0.norm.i[n,,1] %*% B.post) %*% t(Bp.i[n,,1] - B0.norm.i[n,,1] %*% B.post)\n  }\n  \n  if (i != (parameters$S + parameters$S.burnin)){\n    struct$kappa0[i+1] = kappa0.s.post / rchisq(n=1,df = kappa0.nu.post)\n    struct$kappap[i+1] = GIGrvg::rgig(n=1, kappap.lambda.post, kappap.chi.post, kappap.psi.post)\n  }\n  }\n  return(struct)\n  \n}\n\nThe following code computes the prior, initialises matrices to store results, and samples the draws for the simulated data.\n\n\n\nThe following code computes the prior, initialises matrices to store results, and samples the draws for the actual data."
  }
]