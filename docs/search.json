[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Estimating the impact of monetary policy shocks on different housing indicators: An SVAR Approach",
    "section": "",
    "text": "Abstract. <under construction!>\nKeywords. bsvars, impulse responses, quarto, R, housing price index, monetary policy shocks"
  },
  {
    "objectID": "index.html#empirical-project-setup",
    "href": "index.html#empirical-project-setup",
    "title": "Estimating the impact of monetary policy shocks on different housing indicators: An SVAR Approach",
    "section": "Empirical Project Setup",
    "text": "Empirical Project Setup\nThis project website is being developed as a Quarto document and the empirical work in conducted using R. The necessary datasets are imported from the Reserve Bank of Australia (RBA) and the Australian Bureau of Statistics (ABS) websites using readrba and readabs respectively."
  },
  {
    "objectID": "index.html#choice-of-variables",
    "href": "index.html#choice-of-variables",
    "title": "Estimating the impact of monetary policy shocks on different housing indicators: An SVAR Approach",
    "section": "Choice of variables",
    "text": "Choice of variables\nI use the following variables to answer this question. I discuss the relevance of each variable.\n\n\\(\\log(M1)\\): represents the log of the money supply M1. Both conventional and unconventional monetary policy shocks can change the stock of money supply and its size affects real variables of the economy.\n\\(\\Delta CPI\\): represents the year-on-year change in the Consumer Price Index (CPI). It is a measure of inflation in an economy and is affected by monetary policy shocks.\n\\(\\log(c)\\): represents the log of consumption of the economy. Monetary policy shocks can alter people’s consumption-savings behavior.\n\\(\\log(GDP)\\): represents the log of the Gross Domestic Product (GDP). Including this along with the consumption helps differentiate the effect on the non-consumption aspect of the economy.\n\\(loanrate\\): represents the weighted average interest rates on owner-occupied home loans.\n\\(AUCR\\): represents the Australian Cash Rate Target. This is the major monetary policy instrument available to the RBA.\n\\(USFFR\\): represents the Federal Funds Rate Maximum Target Rate. Monetary policy adopted in the US tend to ripple into other economies so this is a variable of interest. Another extension to this variable would be to include the Target rates of Australia’s largest trading partners.\n\\(nhouses\\): represents the number of new private dwellings (houses) approved for construction in Australia. Impact on housing prices might be dampened by the supply elasticity of housing captured by this variable.\n\\(PPI\\): represents the Property Price Index in Australia. The index is normalized with respect to the property prices in 2011-2012."
  },
  {
    "objectID": "index.html#data-properties",
    "href": "index.html#data-properties",
    "title": "Estimating the impact of monetary policy shocks on different housing indicators: An SVAR Approach",
    "section": "Data Properties",
    "text": "Data Properties\nThe variables discussed above are illustrated in the figure below. Note that the logged variables trend upwards because they are expressed in their levels, while variables expressed in percentage change terms do not exhibit this behavior.\n\n\n\n\n\nThe dataset will be used in the sample consists quarterly data from 2003 Q3 to 2021 Q4, including 74 observations, plots of truncated dataset is shown as:\n\n\n\n\n   \n\nNext, I perform and display ADF test results on the variables. I report, for each variable, the difference level at which the ADF tests rejects the null that the series is non-stationary.\n\nperform_adf_tests <- function(df) {\n  # Create an empty dataframe to store the results\n  results <- data.frame(Variable = character(), TestType = character(), \n                        TestStatistic = numeric(), PValue = numeric(), \n                        stringsAsFactors = FALSE)\n\n  # Iterate over each column in the dataframe\n  for (col in colnames(df)) {\n    # Remove NA values from the column\n    column_data <- na.omit(df[[col]])\n\n    # Perform ADF test for levels\n    adf_levels <- tseries::adf.test(na.omit(column_data), k = 4)\n\n    # Check if p-value is less than or equal to 0.05\n    if (adf_levels$p.value <= 0.05) {\n      results <- bind_rows(results,\n        data.frame(Variable = col, TestType = \"Levels\", \n                   TestStatistic = adf_levels$statistic,\n                   PValue = adf_levels$p.value)\n      )\n    } else {\n      # Perform ADF test for first difference\n      adf_diff1 <- tseries::adf.test(na.omit(diff(column_data)), k = 4)\n      \n      # Check if p-value is less than 0.05\n      if (adf_diff1$p.value < 0.05) {\n        results <- bind_rows(results,\n          data.frame(Variable = col, TestType = \"First Difference\", \n                     TestStatistic = adf_diff1$statistic,\n                     PValue = adf_diff1$p.value)\n        )\n      } else {\n        # Perform ADF test for second difference\n        adf_diff2 <- tseries::adf.test(na.omit(diff(column_data, differences = 2)), k = 4)\n        \n        results <- bind_rows(results,\n            data.frame(Variable = col, TestType = \"Second Difference\", \n                       TestStatistic = adf_diff2$statistic,\n                       PValue = adf_diff2$p.value)\n          )\n      }\n    }\n  }\n\n\n  # Return the results dataframe\n  return(results)\n}\n\nadf_test_results <- perform_adf_tests(df)\nrmarkdown::paged_table(adf_test_results)"
  },
  {
    "objectID": "index.html#basic-model",
    "href": "index.html#basic-model",
    "title": "Estimating the impact of monetary policy shocks on different housing indicators: An SVAR Approach",
    "section": "Basic Model",
    "text": "Basic Model\n\nIdentification\nI plan to use exclusion-restrictions to identify the structural matrix \\(B_0\\). In particular, I will employ the solution concept in D. Waggoner and Zha (2003) who use a normalization rule as an optimal solution to the local identification problem. I then employ the Gibbs sampler for a SVAR model with exclusion restrictions as in D. F. Waggoner and Zha (2003).\nThe Structural VAR model for a N-vector of observations at time \\(t\\) can be written in matrix notation as follows\n\\[\\begin{align*}\n  \n\\end{align*}\\]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe setup of the model is rearranged as \\[\n\\begin{align*}\n  Y = AX + BU\n\\end{align*}\n\\]\n\n\n\n\n# set the priors\n\nparameters = list(\n  kappa1    = .1,       # autoregressive slope shrinkage\n  kappa2    = 10,      # constant term shrinkage\n  kappa3    = 10,      # contemporaneous effects shrinkage\n  kappa4    = 1,       # VAR prior persistence\n  S         = 5000,\n  S.burnin  = 100\n)\n\n\n# A function that computes and stores all the prior distribution components given a parameter list input\nprior     = function(parameters, usedata){\n  priors  = list(\n  B       = cbind(rep(0,usedata$N), parameters$kappa4*diag(usedata$N), matrix(0, usedata$N, (usedata$p-1)*usedata$N)), # random walk prior\n  Omega   = diag(c(parameters$kappa2,parameters$kappa1*((1:usedata$p)^(-2))%x%rep(1,usedata$N))),\n  # Omega = diag(c(parameters$kappa2,parameters$kappa1*rep(1,usedata$N*usedata$p))),\n  S       = parameters$kappa3*diag(usedata$N),\n  nu      = usedata$N\n  )\n}\n\n\nposterior     = function(priors, usedata){\n  Omega.inv   = solve(priors$Omega)\n  Omega.post.inv = usedata$X%*%t(usedata$X) + Omega.inv\n  Omega.post  = solve( Omega.post.inv )\n  B.post      = (usedata$Y%*%t(usedata$X) + priors$B%*%Omega.inv) %*% Omega.post\n  S.post      = solve(usedata$Y%*%t(usedata$Y) + solve(priors$S) + priors$B%*%Omega.inv%*%t(priors$B) - B.post%*%Omega.post.inv%*%t(B.post) )\n  nu.post     = ncol(usedata$Y) + priors$nu\n\n  posteriors  = list(\n  B           = B.post,\n  Omega       = Omega.post,\n  S           = S.post,\n  nu          = nu.post\n)\n}\n\n\nltexclusion = function(usedata){\n  BM.V        = vector(\"list\",usedata$N)\nfor (n in 1:usedata$N){\n  BM.V[[n]]   = cbind(diag(n),matrix(0,n,usedata$N-n))\n}\n\nB0.initial    = matrix(0,usedata$N,usedata$N)\nfor (n in 1:usedata$N){\n  unrestricted               = apply(BM.V[[n]],2,sum)==1\n  B0.initial[n,unrestricted] = rnorm(sum(unrestricted))\n}\nB0Vlist       = list(B0.initial = B0.initial, V = BM.V)\n}\n\n\nposteriorSimulations  = function(parameters, posteriors, B0Vlist, N){\n  t0                  = proc.time()\n  B0.posterior        = rgn(n=parameters$S.burnin, S.inv=solve(posteriors$S), nu=posteriors$nu, V=B0Vlist$V, B0.initial=B0Vlist$B0.initial)\n  t1                  = proc.time()\n  (t1-t0)/60\n  \n  # sampling B0 from the posterior distribution using Gibbs\n  t0                  = proc.time()\n  B0.posterior        = rgn(n=parameters$S, S.inv=solve(posteriors$S), nu=posteriors$nu, V=B0Vlist$V, B0.initial=B0.posterior[,,parameters$S.burnin])\n  t1                  = proc.time()\n  (t1-t0)/60\n  \n  # normalisation\n  B0.hat              = t(chol((posteriors$nu-N)*posteriors$S))                   # normalisation using this B0.hat should work\n  BM.B0.posterior     = normalize.Gibbs.output.parallel(B0.posterior,B0.hat=B0.hat)\n  t2                  = proc.time()\n  (t2-t1)/60\n  \n  # sample B+ from the normal conditional posterior\n  t2                  = proc.time()\n  BM.Bp.posterior     = rnorm.ngn(BM.B0.posterior, B=posteriors$B,Omega=posteriors$Omega)\n  t3                  = proc.time()\n  (t3-t2)/60\n  \n  list(B0.posterior   = BM.B0.posterior, Bp.posterior = BM.Bp.posterior)\n}\n\n\nposteriorMeans = function(Bposteriors){\n  Bposteriors.means = list(\n  B0 = rowMeans(Bposteriors$B0.posterior, dims = 2),\n  Bp = rowMeans(Bposteriors$Bp.posterior, dims = 2)\n  )\n}\n\n\n\nSimulation Run\n\n\n\n\nsim.priors      = prior(parameters, artificialdata)\nsim.posteriors  = posterior(sim.priors, artificialdata)\n\n\nsim.B0Vlist   = ltexclusion(artificialdata)\n\n\n\n\n\n\n\n\nsim.Bposteriors.means = posteriorMeans(sim.Bposteriors)\n\n\n\nData Results"
  },
  {
    "objectID": "index.html#extended-model",
    "href": "index.html#extended-model",
    "title": "Estimating the impact of monetary policy shocks on different housing indicators: An SVAR Approach",
    "section": "Extended Model",
    "text": "Extended Model\nIn the extended model, I will estimate the hyperparameters using a triple gamma prior.\n\nIdentification"
  }
]